# 문서 관리 프로세스

챗봇이 참조하는 `knowledge/` 문서를 관리하는 세 가지 방법과, 프론트엔드 코드 변경 시 문서가 자동으로 업데이트되는 CI/CD 파이프라인을 설명합니다.

---

## 문서 관리 방법 요약

| 방법 | 접근 경로 | 대상 | 특징 |
|------|----------|------|------|
| 관리 UI | `{서버주소}/manage` | 비개발자 포함 누구나 | 웹 에디터 + 미리보기 + 챗봇 도우미 |
| 직접 파일 편집 | `bot/knowledge/` 폴더 | 개발자 | 로컬에서 직접 `.md` 파일 수정 |
| CI/CD 자동 업데이트 | GitHub Actions | 자동 | 프론트엔드 코드 변경 시 AI가 문서 수정 PR 생성 |

---

## 1. 관리 UI (`/manage`)

봇 서버는 `{서버주소}/manage` 경로에서 웹 기반 문서 관리 UI를 제공합니다.
개발자가 아니더라도 브라우저에서 knowledge 문서를 조회하고 편집할 수 있습니다.

### 접근 방법

- 로컬: `http://localhost:8000/manage`
- 배포 환경: `{Cloud Run 서비스 URL}/manage`

### 주요 기능

#### 문서 편집기

| 기능 | 설명 |
|------|------|
| 문서 목록 | 좌측 사이드바에서 knowledge/ 문서 목록을 확인하고 선택 |
| 마크다운 편집 | 선택한 문서를 마크다운 에디터에서 직접 편집 |
| 미리보기 | 편집/미리보기 탭 전환으로 렌더링 결과 실시간 확인 |
| 저장 | 저장 버튼 또는 `Ctrl+S`(`Cmd+S`)로 저장 |
| 되돌리기 | 저장 전 변경사항을 원래 내용으로 복원 |
| 자동 반영 | 저장 시 watcher가 변경을 감지하여 ChromaDB에 자동 동기화 |

#### 문서 도우미 챗봇

관리 UI 우측 하단의 플로팅 버튼을 클릭하면 **문서 도우미 챗봇**이 열립니다.

| 항목 | 설명 |
|------|------|
| 용도 | 찾고 싶은 내용이 어느 문서에 있는지 검색 |
| 동작 방식 | `/rag/locate` 엔드포인트를 호출하여 RAG 기반으로 관련 문서 위치를 탐색 |
| 응답 내용 | 답변 텍스트 + 관련 문서 위치 카드 (파일명, 섹션, 발췌 내용) |
| 문서 열기 | 위치 카드를 클릭하면 해당 문서가 에디터에 바로 열림 |

**사용 예시:**
```
사용자: "벙 만드는 방법은 어디에 있어?"
챗봇: "벙 만들기에 대한 내용은 다음 문서에서 확인할 수 있어요."
      → [📄 벙 만들기] 카드 표시 → 클릭 시 해당 문서 열림
```

### 관리 UI 동작 흐름

```
관리자가 /manage 접속
    ↓
좌측 사이드바에서 문서 선택 (GET /documents/{filename})
    ↓
에디터에서 내용 편집
    ↓
저장 버튼 클릭 (PUT /documents/{filename})
    ↓
watcher.py가 파일 변경 감지
    ↓
해당 문서의 기존 벡터 삭제 → 새로 청크 분할 → ChromaDB에 저장
    ↓
챗봇이 수정된 내용으로 즉시 답변
```

### 관련 API 엔드포인트

| 메서드 | 경로 | 설명 |
|--------|------|------|
| GET | `/manage` | 관리 UI HTML 페이지 서빙 |
| GET | `/documents` | 문서 목록 조회 (사이드바 표시용) |
| GET | `/documents/{filename}` | 특정 문서 내용 조회 |
| PUT | `/documents/{filename}` | 문서 내용 수정 |
| POST | `/rag/locate` | 문서 도우미 챗봇 - 관련 문서 위치 검색 |
| POST | `/documents/sync` | 전체 문서 수동 동기화 |
| DELETE | `/documents/reset` | 벡터 DB 초기화 |

---

## 2. 직접 파일 편집

개발자는 `bot/knowledge/` 폴더의 마크다운 파일을 직접 편집할 수 있습니다.

### 편집 방법

```bash
# 로컬에서 직접 편집
vi bot/knowledge/01_서비스_개요.md

# 또는 IDE에서 열어서 편집
code bot/knowledge/
```

### 반영 과정

- **로컬 개발 환경**: 서버가 실행 중이면 watcher가 파일 변경을 감지하여 ChromaDB에 자동 반영
- **Docker 환경**: `knowledge/` 폴더가 볼륨 마운트되어 있으므로 로컬 파일 변경이 컨테이너에 실시간 반영
- **배포 환경**: 파일을 커밋 & 푸시하면 `bot-deploy.yml`이 트리거되어 새 이미지 빌드 후 배포

### 문서 작성 규칙

| 항목 | 규칙 |
|------|------|
| 파일 형식 | `.md` 또는 `.txt` |
| 파일명 규칙 | `{번호}_{제목}.md` (예: `01_서비스_개요.md`) |
| 인코딩 | UTF-8 |
| 청크 분할 | 500자 단위, 50자 오버랩으로 자동 분할됨 |

### 현재 문서 목록

| 파일명 | 내용 |
|--------|------|
| 01_서비스_개요.md | 오픈런 서비스 소개 |
| 02_회원가입_및_로그인.md | 회원가입/로그인 안내 |
| 03_홈_화면.md | 홈 화면 기능 설명 |
| 04_벙_만들기.md | 벙 생성 가이드 |
| 05_벙_상세_및_관리.md | 벙 상세/관리 기능 |
| 06_탐색_및_검색.md | 탐색/검색 기능 |
| 07_도전과제.md | 도전과제 시스템 |
| 08_아바타.md | 아바타 기능 |
| 09_프로필.md | 프로필 기능 |
| 10_용어_사전.md | 서비스 용어 정리 |

---

## 3. CI/CD 자동 문서 업데이트

프론트엔드 코드가 변경되면, 해당 변경이 서비스 사양에 영향을 주는지 AI가 자동으로 분석하고, 영향이 있을 경우 knowledge 문서를 수정하는 Pull Request를 생성합니다.

### 리포지토리 구조

프론트엔드와 봇은 **별도의 GitHub 리포지토리**로 관리됩니다. 크로스 리포 `repository_dispatch`를 통해 연동합니다.

| 리포지토리 | 역할 |
|-----------|------|
| `open-run/frontend` | 프론트엔드 코드 (Next.js) |
| `windragon0807/open-run-smartbot` | 봇 서버 + knowledge 문서 |

### 전체 흐름

```
① 프론트엔드 코드 변경 → main 브랜치에 push
        ↓
② [frontend 리포] notify-bot-repo.yml 실행
   - src/** 변경 감지
   - 의미 있는 변경인지 확인 (CSS, 테스트 파일 제외)
        ↓
③ [frontend → bot] repository_dispatch 이벤트 전송
   - event_type: "frontend-changed"
   - 커밋 SHA (before, after) 전달
        ↓
④ [bot 리포] doc-sync.yml 트리거
   - bot 리포 checkout (knowledge/ 접근)
   - frontend 리포 별도 checkout (diff 추출용)
        ↓
⑤ generate_docs.py가 frontend 리포의 git diff를 OpenAI에 보내서 분석
   "이 코드 변경이 서비스 사양에 영향을 주는가?"
        ↓
⑥ 영향 있음 → knowledge/ 문서 자동 수정 → PR 생성 (bot 리포에)
   영향 없음 → 아무 일도 일어나지 않음
        ↓
⑦ 팀원이 PR 리뷰 후 머지
        ↓
⑧ [bot 리포] bot-deploy.yml 실행 (main push 감지)
        ↓
⑨ Docker 이미지 빌드 (수정된 knowledge/ 포함)
        ↓
⑩ GCP Cloud Run에 자동 배포
        ↓
⑪ 봇 서버 재시작 → watcher.py가 knowledge/ 전체를 ChromaDB에 동기화
        ↓
⑫ 챗봇이 최신 사양으로 답변
```

### 워크플로우 1: 프론트엔드 변경 알림 (`notify-bot-repo.yml`)

**위치**: frontend 리포 (`.github/workflows/notify-bot-repo.yml`)

- **트리거**: `main` 브랜치에 `src/**` 경로 변경이 push될 때
- **동작**:
  1. CSS, 테스트 파일을 제외한 의미 있는 변경이 있는지 확인
  2. 변경이 있으면 bot 리포에 `repository_dispatch` 이벤트 전송
  3. 커밋 SHA (before, after)와 리포 정보를 payload로 전달
- **필요한 Secret**: `BOT_REPO_PAT` (bot 리포에 dispatch를 보낼 수 있는 Personal Access Token)

### 워크플로우 2: 문서 자동 업데이트 (`doc-sync.yml`)

**위치**: bot 리포 (`.github/workflows/doc-sync.yml`)

- **트리거**: `repository_dispatch` (type: `frontend-changed`)
- **동작**:
  1. bot 리포 checkout (knowledge/ 문서 접근)
  2. frontend 리포 별도 checkout (`_frontend/` 디렉토리에)
  3. `generate_docs.py --mode ci --apply --frontend-dir _frontend/ --before <SHA> --after <SHA>` 실행
  4. 스크립트가 frontend 리포의 `git diff`로 변경사항 추출
  5. 현재 knowledge/ 문서와 함께 OpenAI API에 전달
  6. AI가 "사양에 영향을 주는 변경인지" 판단
  7. 영향이 있으면 문서를 수정하고 PR 자동 생성
- **결과**: `docs/auto-update` 브랜치에 PR이 생성됨
- **중요**: 자동 머지가 아닌, **팀원이 리뷰 후 머지**해야 반영됨

### PR 리뷰 체크리스트

AI가 생성한 PR에는 다음 확인 사항이 포함됩니다:

- [ ] 변경된 문서 내용이 정확한지 확인
- [ ] 불필요한 변경이 포함되어 있지 않은지 확인

리뷰어는 AI가 제안한 문서 수정이 실제 코드 변경과 일치하는지 검토한 후 머지합니다.

### 워크플로우 3: 봇 서버 배포 (`bot-deploy.yml`)

**위치**: bot 리포 (`.github/workflows/bot-deploy.yml`)

위 PR이 머지되면 main 브랜치에 push가 발생하므로 배포 워크플로우가 자동 트리거됩니다.

- **트리거**: `main` 브랜치에 push될 때
- **동작**:
  1. Docker 이미지 빌드 (`Dockerfile` 사용)
  2. GCP Artifact Registry에 이미지 push
  3. GCP Cloud Run에 배포
- **배포 환경**:
  - 리전: `asia-northeast3` (서울)
  - 메모리: 1Gi, CPU: 1
  - 인스턴스: 0~3개 (요청 없으면 0으로 스케일다운)
  - 포트: 8000

### generate_docs.py 스크립트

AI 문서 자동 업데이트의 핵심 스크립트입니다.

```bash
# CI에서 사용 (크로스 리포 — frontend 리포 경로와 커밋 범위 지정)
python scripts/generate_docs.py --mode ci --apply \
  --frontend-dir /path/to/frontend --before abc123 --after def456

# 로컬 모노리포에서 사용 (기존 방식 호환)
python scripts/generate_docs.py --mode ci --apply

# 수동 분석 (적용 없이 결과만 확인)
python scripts/generate_docs.py --mode api --from-ref HEAD~5 --to-ref HEAD
```

**처리 과정**:
1. `git diff`로 프론트엔드 변경사항 추출 (CSS, 테스트 파일 제외)
   - `--frontend-dir` 지정 시: 해당 디렉토리에서 `src/` 기준 diff
   - 미지정 시: 모노리포 루트에서 `frontend/src/` 기준 diff
2. knowledge/ 폴더의 모든 문서를 읽어옴
3. diff + 문서를 OpenAI API에 전달하여 분석
4. 사양 변경이 있으면 수정된 문서 내용을 JSON으로 반환
5. `--apply` 옵션이 있으면 파일에 직접 저장

**AI 분석 기준**:
- 사용자 경험이나 서비스 사양에 영향을 주는 변경만 반영
- 단순 리팩토링, 스타일 변경, 버그 수정은 무시
- 보수적으로 판단하여 확실한 사양 변경만 문서에 반영

### 필요한 GitHub Secrets

#### frontend 리포 (`open-run/frontend`)

| Secret 이름 | 용도 | 설정 방법 |
|-------------|------|----------|
| `BOT_REPO_PAT` | bot 리포에 repository_dispatch 이벤트 전송 | GitHub Settings > Developer settings > Personal access tokens > Fine-grained tokens에서 생성. `windragon0807/open-run-smartbot` 리포에 대해 `Contents: Write` 권한 부여 |

#### bot 리포 (`windragon0807/open-run-smartbot`)

| Secret 이름 | 용도 | 설정 방법 |
|-------------|------|----------|
| `OPENAI_API_KEY` | generate_docs.py의 AI 분석 + Cloud Run 환경변수 | OpenAI 대시보드에서 발급 |
| `GCP_DEPLOYMENT_SA_KEY` | GCP 서비스 계정 키 (Cloud Run 배포용) | GCP IAM에서 서비스 계정 키 JSON 발급 |
| `FRONTEND_REPO_PAT` | frontend 리포 checkout 용 | GitHub PAT. `open-run/frontend` 리포에 대해 `Contents: Read` 권한 부여 |
| `GITHUB_TOKEN` | PR 자동 생성 | 기본 제공 (별도 설정 불필요) |

---

## 프론트엔드 챗봇

프론트엔드(Next.js) 앱에도 사용자용 챗봇이 내장되어 있습니다.

### 관리 UI 챗봇과의 차이

| 항목 | 프론트엔드 챗봇 | 관리 UI 챗봇 |
|------|----------------|-------------|
| 대상 | 서비스 사용자 (일반 유저) | 문서 관리자 |
| 위치 | Next.js 앱 내 플로팅 버튼 | `/manage` 페이지 내 플로팅 버튼 |
| API 경로 | `/api/chat` → `/rag/query` | `/rag/locate` |
| 응답 방식 | 질문에 대한 답변 + 참고 문서 태그 | 답변 + 문서 위치 카드 (클릭 시 에디터에서 열림) |
| 목적 | 서비스 이용 안내 | 문서 내용 탐색 및 편집 지원 |

### 프론트엔드 챗봇 요청 흐름

```
사용자가 질문 입력
    ↓
Next.js API Route (POST /api/chat)
    ↓
봇 서버 (POST /rag/query) — RAG 파이프라인 실행
    ↓
ChromaDB에서 관련 문서 검색 → GPT-4o-mini가 답변 생성
    ↓
응답: { answer, sources }
```

---

## 문서 변경 반영 타이밍 정리

| 변경 방법 | 벡터 DB 반영 시점 | 비고 |
|-----------|-----------------|------|
| 관리 UI에서 저장 | 즉시 (watcher 감지) | 서버 재시작 불필요 |
| 로컬 파일 직접 편집 | 즉시 (watcher 감지) | 서버가 실행 중이어야 함 |
| CI/CD PR 머지 후 배포 | 서버 재시작 시 전체 동기화 | 배포 완료까지 수 분 소요 |
| 수동 동기화 API 호출 | 즉시 | `POST /documents/sync` |
